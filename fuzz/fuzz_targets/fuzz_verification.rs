// SPDX-License-Identifier: AGPL-3.0-or-later
//! Fuzz target for proof verification module.
//!
//! Tests the verification logic with arbitrary board states to find
//! crashes, panics, or logic errors in piece placement and proof checking.

#![no_main]

use libfuzzer_sys::fuzz_target;

// Import from the main crate
use proof_of_work::game::{BoardState, GoalCondition, Level, LogicPiece};
use proof_of_work::game::validation::{validate_board, validate_piece_placement};
use proof_of_work::verification::verify_level_solution;

/// Generate a LogicPiece from fuzz input bytes.
fn piece_from_bytes(data: &[u8], offset: usize) -> Option<LogicPiece> {
    if offset + 4 > data.len() {
        return None;
    }

    let piece_type = data.get(offset)? % 8;
    let x = *data.get(offset + 1)? as u32 % 20;
    let y = *data.get(offset + 2)? as u32 % 20;
    let extra = *data.get(offset + 3)?;

    Some(match piece_type {
        0 => LogicPiece::Assumption {
            formula: match extra % 4 {
                0 => "P".to_string(),
                1 => "Q".to_string(),
                2 => "R".to_string(),
                _ => "S".to_string(),
            },
            position: (x, y),
        },
        1 => LogicPiece::Goal {
            formula: match extra % 4 {
                0 => "P".to_string(),
                1 => "Q".to_string(),
                2 => "R".to_string(),
                _ => "S".to_string(),
            },
            position: (x, y),
        },
        2 => LogicPiece::AndIntro { position: (x, y) },
        3 => LogicPiece::OrIntro { position: (x, y) },
        4 => LogicPiece::ImpliesIntro { position: (x, y) },
        5 => LogicPiece::NotIntro { position: (x, y) },
        6 => LogicPiece::ForallIntro {
            position: (x, y),
            variable: "x".to_string(),
        },
        _ => LogicPiece::Wire {
            from: (x, y),
            to: ((x + extra as u32) % 20, (y + 1) % 20),
        },
    })
}

/// Generate a BoardState from fuzz input.
fn board_from_bytes(data: &[u8]) -> BoardState {
    if data.len() < 2 {
        return BoardState {
            width: 10,
            height: 10,
            pieces: Vec::new(),
        };
    }

    let width = (data[0] as u32 % 30).max(5);
    let height = (data[1] as u32 % 30).max(5);
    let mut pieces = Vec::new();

    // Generate pieces from remaining bytes
    let mut offset = 2;
    while offset + 4 <= data.len() && pieces.len() < 50 {
        if let Some(piece) = piece_from_bytes(data, offset) {
            pieces.push(piece);
        }
        offset += 4;
    }

    BoardState {
        width,
        height,
        pieces,
    }
}

/// Generate a Level from fuzz input.
fn level_from_bytes(data: &[u8]) -> Level {
    let board = board_from_bytes(data);

    let goal_type = data.first().unwrap_or(&0) % 3;
    let goal_state = match goal_type {
        0 => GoalCondition::ProveFormula {
            formula: "R".to_string(),
        },
        1 => GoalCondition::ConnectNodes {
            start: (2, 5),
            end: (8, 4),
        },
        _ => GoalCondition::BuildProofTree { depth: 3 },
    };

    Level {
        id: 1,
        name: "Fuzz Level".to_string(),
        description: "Generated by fuzzer".to_string(),
        theorem: "(assert (=> (and P Q) R))".to_string(),
        initial_state: board,
        goal_state,
    }
}

fuzz_target!(|data: &[u8]| {
    // Generate arbitrary board state
    let board = board_from_bytes(data);

    // Test validation doesn't panic
    let _ = validate_board(&board);

    // Test piece placement validation
    for piece in &board.pieces {
        let _ = validate_piece_placement(&board, piece);
    }

    // Generate and verify a level
    let level = level_from_bytes(data);

    // Test verification doesn't panic
    // (verification may return true or false, we just want no crashes)
    let _ = verify_level_solution(&level, &level.initial_state.pieces);
});
